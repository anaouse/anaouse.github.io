---
title: shixian7
date: 2025-09-02
author: anaouse
layout: doc
---

## 休息

做事情带来的乐趣引导一直做下去，但是开始做并体会到乐趣需要精力，需要自己确认现在是安全的，没有多余的干扰这个时候才可以开始体会乐趣，所以需要真正的休息来隔绝外在的所有事物，心里很平然后恢复精力。

## 人造困境

感觉躺久了还真的不太行，可以直接人造一些困境给自己，限定时间直面某种困难还是很有意思的。

## 做啥

感觉已经厌倦了鼠标无意义的点来点去，以及和AI复制粘贴了，已经到了一种不知道该做什么的地步，打算回归书籍和纸笔，希望30岁的时候在计算机，电子音乐，数学，以及各种自己感兴趣的问题下的视角更加广阔，能看到更多东西，一次学一个东西，学懂了有些练习与笔记然后再往前就好了。用脑和不用脑的差距还是很明显的。

## 实用

回归写代码的实用性，要完成一种目标，而不是留在脑海当中。在一个恰当的抽象层面开始写代码，不用无脑追求底层，到一个满足自己自定义要求的层面即可。

真要搞些底层的，要么自己感兴趣要么也要搞一个感觉有用的东西为目标，而不是我跑过这样的东西，这说明不了什么。

## 文档

感觉有一个清晰的文档就很舒服

## 和 AI 练习

每天一个库或者语法的练习保持写代码的手感的同时接触新的工具

give me several problem and answer to practise (xxxx) usual usage and api, and final give me a composite problem

- done:

Windows窗口创建过程，了解Windows消息机制

std::function

opengl basic usage

std::format

- todo list:

function pointer

for(const auto& [name, func]:functions) std::pair???

std::find_if and find()?

F&& ???

## 重复

重复的东西必须要很清晰才有一点意思，这样不至于又混乱又重复，心神疲惫。

## 复制粘贴之外

和AI聊天要带上自己的理解，让自己脑子参与进去，而不是简单地提问什么是什么这样子。

## 未来的日子与醒着

该怎么样在任何地方存活下去，以及醒着的时候做什么事情是必要的东西，是所有人都要面对的事情，原来一直呆在学校里面，可以拿写作业以及上课来糊弄过去，但是这一切外在的推动力都消失之后，还是要自己去找可以做的事情，这时候也许有人又会赶紧选择一大段新的东西来占满自己未来的几年时间，但是经过这个暑假的经历看来，现代我国躺平环境真的还算不错，虽然现在正在找工作，啃老当中，但是感觉日常生活需要的钱真的不是很多，这就现得时间很珍贵。

最近突然感觉，白天不想起，晚上不想睡的日子根本不值得度过，在白天不去做想做的事，而是在夜晚幻想自己去做事这样的情况就是完全陷入互联网的丰富多彩当中了。实际上白天都可以亲身去体验与创造，但是偏偏要留到晚上去看别人的体验和创造就很怪。

无论为了活下去或是谋生，或是跟随某种社会的秩序，能够让人白天不愿意从床上起来这样的环境以及自身真的非常奇怪。即使是休息不够，每天的白天理论上应该有想做的事，想见的人，想看的书等东西激励起床，但是现在即使是休息足够了，还是不愿意起来，这样的节奏完全不对。

醒着的时候就那么痛苦吗？让以前的我不愿意从床上起来。如果不去自己回答要过什么样的日子以及醒着的时候做什么的话好像确实就会那么痛苦导致不愿意醒来，即使醒来也难以去主动面对困难，主动去体验创造，或者时刻紧绷着，遇到事情不能按时推进就很痛苦啥的。

感觉短期面对困难以及接受困难带来的压力与失败是必要的，当然是短期的而不是一直存在的高压环境。为了逃避现实的困难与失败，在白天做各种各样简单的，实际上对自己而言可有可无的事情来安抚与麻痹内心，到晚上又在互联网当中假象自己得到了各种体验与成就。这里临时说一句，这也是我不看好用AI做单纯的陪伴聊天类型应用的原因，这样的东西必须在现实中得到。

前段时间，面试官出了中等难度的算法题，我不会写，后来又给一道简单的，暴力解出来，最后还是没想出最优的解法，体会到的压力与失败是必要的，但是这样的东西完全不应该变成醒着时候的痛苦，这是没有办法的事情，我5月份才开始决定以后要写c++，leetcode也才写了50题不到，但是秋招还是得参加，没实习，代码还不熟练也得开始，醒着的日子就是这样的，不然做什么呢，至少这样的方向是积极主动去选择的。

能够把醒着的困难与失败当成临时的而不是永恒的东西的关键在于松弛感，或者内心的平和。感觉这说法被提及很多次了，但是事实上就是这样的，错过了，没赶上确实很亏，但是有什么办法？总不能不活了吧，fomo以及对未来的焦虑会让醒着痛苦，反倒是阻止了自己的发展。这又突然想说，现代社会是真的舒服，想学什么上个网就能入门，全看个人的意愿与时间的分配。

突然又想说，写作的时候突然产生的想法算是写作的乐趣之一，从一个想写的东西开始不断产生更多想写的东西。

## 协程

单线程按顺序执行，如果遇到等待就把自己挂起，让线程接着按顺序执行，用户态的调度，状态存在堆当中

## 自然而然的注意力

感觉一旦开始做一件事情三到五分钟左右就会自然而然地做下去，阻力比开始做要少很多，这时候如果不想做了要么就是真的累了，要么就是做的事真的非常无聊。不管是还是什么刷手机还是学习之类的。

## flutter gradle network error

https://developer.aliyun.com/article/1583258

D:\cpptool\app\learn\android\gradle\wrapper\gradle-wrapper.properties

D:\cpptool\app\my_first_app\android\build.gradle.kts

## 哎，移动端
 
为什么要有那么多依赖以及各种互联网下载第三方库，我下好了还不用我的版本还自己下一个，给我气笑了😄

## 随机提示音

**road map**
- 搞一个按钮可以点击开始或者停止(done)
- 三个输入框输入持续时间以及随机的起始时间(done)
- 让timer可以在后台运行, 包括退出应用以及锁屏的时候(done)


setState is the Messenger, receive a callback function

a StatefulWidget is split into two classes—the Widget class and the State class—to handle immutability and mutability separately.

一个无状态类表示一个东西的存在, 使用另外一个状态类管理这个东西的状态, 可点击的按钮, 那么这个按钮的存在是不变的, 另外使用一个类去维持这个按钮造成的状态变化

代码流程:

WidgetsFlutterBinding.ensureInitialized();// 异步初始化插件或服务之前使用
await initializeService();// 创建service以及把回调函数结合给这个service
	androidConfiguration: AndroidConfiguration(
      onStart: onStart,
      autoStart: false,// 手动调用service.startService()才开始, 否则跟着APP一起开始
      isForegroundMode: true, // 前台模式, 有常驻通知
    ),

	onstart
		service.on('xxx').listen((event) { ... });
		// 订阅了一个名字叫 "xxx" 的事件，当别人调用 service.invoke("xxx", data) 时，这里会触发。
		// service.on返回一个流, 然后流有listen方法每当流里有新数据，就会调用的回调函数。

runApp -> Flutter 框架创建 HomePage -> 调用 `HomePage.createState()` -> 得到一个 `_HomePageState` 对象 → 调用 `_HomePageState.build()` -> 渲染界面

有一个类说明要有这个东西, 然后状态类先有状态然后再根据状态build

runApp
	MyApp
		build //返回一个MaterialApp, 里面有HomePage, 它是一个 顶层容器 Widget，相当于你的 Flutter 应用的“壳子”, 提供统一的UI。

	HomePage
		createState // 返回创造状态的方法, 现有状态再根据状态来build, 很何理

Stateful Widget当中, 初始化: 在 initState() 中进行一次性设置。更新: 在 setState() 中响应状态变化。清理: 在 dispose() 中释放资源。

	_HomePageState
		StreamSubscription<Map<String, dynamic>?>? _serviceSubscription;
		_serviceSubscription = service.on('update_timer').listen返回一个类似于订阅凭证, 可以用来操控是否继续订阅或者啥的
		Map<String, dynamic>为这个流返回的类型, event['formatted_time'], dynamic（可以是任何类型）

对于我而言变成了一个没用的需求, 因为我不用这个来专注, 一开始bilibili看到一个视频介绍的, 我知道我不用来专注, 原本以为可以用来排除掉不专注的时候, 但是后面发现根本不需要, 只要习惯了沉浸到任何事情包括刷视频, 直播等等当中都可以很快知道自己是否在专注的状态, 我也不需要这样的软件来提示休息, 因为可以大概知道看到哪里或者想到哪一步就知道这是一个节点, 可以休息一下了

## codemap

sublime插件设置原理，左窗口自带的自读，直接复制到有窗口然后加自己需要的，codemap就很舒服，可以把函数类什么的解析出来，像是github上面浏览代码一样，自定义解析方法就好了

## 开始尝试使用双拼

感觉很有节奏感，就是一开始打字很慢，但是慢慢来吧，很强调平舌和翘舌的区分

最后还是放弃了，感觉脑子很不舒服，虽然手确实舒服很多，但是感觉还是没必要，全拼加简写足够舒服加速度够快了。

## opengl music visualizer

create a frameless window

make the window can be draged: use callback function

make the code modularity

## 写作

因为开始使用双拼，所以在打字的时候也感觉自己在获得某种收获，很有意思。

不由自主想到了笔力这个话题，每天能够表达足够多的文字得到的收获或许被远远低估了。

一段逻辑通顺的文字包含的东西有对上下文的短期记忆，文字越长，逻辑越复杂对人脑的考验越大。

而且写作的过程充满实时的反馈，文字打出来就很舒服，和键盘的交互也会暗示大脑，感觉自己正在创作了不起的物品。不会付出而没有收获，因为实时刻刻都是收获。

突然感觉每个人每天的脑力都是有限的，真的是一种可以被用完的东西。开始学双拼的今天大部分脑力都消耗在了打字上面，所以每天要做的其实就是好好休息，避免burn out，以及可以把自己的脑力放在自己喜欢的地方，没有物质上的和情绪上的负债的前提下做一些事情

## 动脑与深入

现在的关键在于对代码，现实世界，数学世界的深刻理解才能够很舒服地享受build的快感，而这其中落实到个人的时候最终还是看脑子的活动，学到各种模式逻辑，才可以很舒服地把各种东西串起来，不然一切都是黑盒子甚至根本想不到那方面，因为根本无法理解，就像现在完全无法理解一样从文字到大模型输出过程是什么，只知道大概的Transformer是，深度学习之类，这样浅显的知道完全没有任何作用，都是浏览器一搜或者问一下AI就知道的东西，所有把事情做成的关键都在于足够大闹内存和见识过足够的东西，再加上脑子的智能呢个，从各种chunk的信息当中找到把一切串起来的那条线。所以学习就是得让知道的东西越来越多，而不是借助AI实现各种东西，那样是干活，不是学习。

AI目前感觉还是作为大号搜索引擎使用，查一查API或者理解简单的逻辑比较好

真正的理解才是节约时间

## emulator 打开的手机跳到Windows屏幕外

[Android SDK路径]\emulator\qemu\windows-x86_64\qemu-system-x86_64.exe

找到 qemu-system-x86_64.exe 这个文件后，在它上面点击鼠标右键，选择 “属性 (Properties)”。
切换到 “兼容性 (Compatibility)” 选项卡。
点击 “更改高 DPI 设置 (Change high DPI settings)” 按钮。
覆盖缩放行为。
在新的窗口中，勾选底部的 “替代高 DPI 缩放行为 (Override high DPI scaling behavior)”。
在下方的下拉菜单中，选择 “系统 (System)” 或者 “系统（增强）(System (Enhanced))”。通常“系统”的效果最好。
点击“确定 (OK)”，再点击“应用 (Apply)” 和 “确定 (OK)”。
完全关闭并重启模拟器。
非常重要：确保模拟器已经完全关闭（可以在任务管理器里检查一下）。
现在从 Android Studio 的 Device Manager 中重新启动它。
这次启动后，模拟器窗口应该就不会再乱跳了，会稳定地出现在你设定的位置，并且内部的手机屏幕也会完整显示。

## async/await

async的函数一直执行, 直到遇到await然后放弃自己, 不阻塞主线程, 等到await结束后主线程再接着执行async函数await之后的东西

## 得到一个人的所有url

得到一个用户的所有发言与帖子是一个很好的需求, 但是现代社交媒体都阻止了这样的行为, 只能一直往下滑, 但是下一次忘记看到哪了, 而且又得划很久, 甚至X好像有机制阻止一直往下滑, 我划过多了直接帮我自动刷新.

只想让用户不断消化新产生的内容, 而不让用户查看以前的内容, 可以让视频与文章话题不断被消费, 也避免了以前说的话被别人翻出来 

## 自顶向下

感觉最近发现了一个有点意思的玩法, 从最表面开始不断探索一个东西有关的侧面或者深层, 这种不断深入的感觉很爽, 最后发现要么感觉没有意思或者东西太多太复杂了, 然后放弃, 要么发现这个东西需要很多物质方面的支持才可以实现然后放弃, 总之这种自顶向下的探索与挖掘非常有意思, 而且有一台电脑以及想去这么做, 想知道为什么就可以开始玩. 可以延伸出各种各样的东西, 可以选择各种各样的抽象层次, 不想了解太底层就到一定程度适可而止, 先了解深入一般最后会遇到物质层面的障碍, 但是就很舒服, 感觉现实世界瞬间变成了一种开放世界, 比游戏还开放的那种, 只需要精力, 时间和热情. 相当于在一个复杂系统的最上面要不断找到往下走的道路.  

## '[' 的探索

想看一下开的debian服务器有多少个可以直接使用的可执行文件的命令, 然后叫AI写了python程序扫描$PATH路径, 得到里面的可执行文件, 结果发现第一个居然是'['

得知'[' 和 test命令类似, 可以查看某个文件是否存在等多种用法, 但是逻辑真为0, 假为1, 感觉很反直觉问了一下AI:

当程序遇到多种错误时，就很难区分是“假”还是“错误”。

以 test 为例，它有三种退出状态码：

0：表达式为真。

1：表达式为假。

2：语法错误（如缺少参数）。

确实有点道理. 

后来想看看如何实现的, 找到源代码:

https://github.com/coreutils/coreutils/blob/master/src/test.c

发现错误提示不一样, 才发现一些常用的命令是bash自带的这样不用另外运行一个进程, 更快速, test就是这样, 通过宏一份代码使用两次, 一次有main函数相当于一个独立的程序, 一词没有直接聚合到bash里面

type test可以查看是不是build in bash的, which test查看哪里有test命令

## 需求

突然感觉不知道该干嘛, 对于我而言, 能够看到动漫以及听到音乐很重要, 对于爱玩游戏的人而言, 能玩到游戏以及各种各样的细致需求很重要, 对于投机与投资的人而言, 得到市场的消息很重要.  各种QKV的方法很重要但是没有那么有意思, 除非能看到优化的数值或者知道有很多人用之类的, 要么满足了别人的需求, 要么自己搞得爽, 除此之外都可以大胆地先排除, 真有用到时候再说, 写用得上的东西就很舒服, 因为真正地节约了时间. 除此之外, 因为时间有限, 每个人都只能选择自己关心的话题去研究, 这就关乎到个人的品味方面. 

## 安卓方便写入的记事本

手机自带便签的小部件占用四格面积, 而且没有搜索功能, 而且不能打开就跳转到最底部并打开键盘等待输入

而且为什么自带的APP都像是社交媒体一样采用下滑而不是分页的形式? 下滑一点也不适合归档收集

以上三个需求都是直接加速我对于手机的使用的适合写的使用场景多的情况, 我使用手机来记录看过的动漫以及专辑, todo事项等

USB连接电脑可以直接访问com.example.learn之下获取txt笔记

v3-正常运行但是很多代码好像是多余的

v4-删除没用的代码

---

navigatorKey: navigatorKey获取控制MyApp的Navigator, 页面状态

---

MethodChannel: flutter和原生之间的通信, flutter用回调函数监听原生代码, 等待invokeMethod

---

context: widget 在 UI 树中的位置

---

`MaterialPageRoute(builder: (_) => NotePage(filePath: filePath))`=>builder是一个函数参数, 不要参数context, MaterialPageRoute是页面跳转的“路线”定义（带动画）

```
MaterialPageRoute(
  builder: (BuildContext context) {
    return NotePage(filePath: filePath);
  },
);
```
---

枚举之下, 拓展函数方法

`final status = await Permission.manageExternalStorage.request();`=>

```
enum Permission {
  camera,
  contacts,
  location,
  manageExternalStorage,
  // ...
}
extension PermissionActions on Permission {
  Future<PermissionStatus> request() async {
    // 调用原生平台 (Android/iOS) 的权限请求
  }
}
```

---

一个StatefulWidget的State对象:

createState() → initState() → build() → (mounted == true)

dispose() → (mounted == false)

`bool get mounted => _mounted;`

`_metadataFile!.exists()`=>'!' 向编译器保证一个可能为null的变量这时候不为null

---

AppLifecycleState.inactive
AppLifecycleState.hidden                                         
AppLifecycleState.paused
App state changed to: AppLifecycleState.resumed 

---

WidgetsBindingObserver用于监听软件的变化情况

---

State类的widget就是制造它的那个类传承下来的

```
class NotePage extends StatefulWidget {
  final String filePath;
  const NotePage({super.key, required this.filePath});

  @override
  State<NotePage> createState() => _NotePageState();
}
```
`_NotePageState`当中可以使用widget.filePath就是NotePage的filePath

---

使用flutter组件自带的东西就可以聚焦移动光标之类的

---

Flutter 的 Android 项目中，MainActivity 默认继承 FlutterActivity，它负责：

启动 Flutter 引擎 显示 Flutter 界面 与原生 Android 系统交互（例如快捷方式、Intent 等）

---

FlutterEngine 是 Flutter 的核心引擎，负责运行 Dart 代码。

MethodChannel 创建了一个桥梁：

Flutter 端可以调用 Kotlin 的 createShortcut

Kotlin 端也可以调用 Flutter 的 openNote

Handler 的逻辑：

Flutter 调用 createShortcut，Kotlin 创建桌面快捷方式。

冷启动处理：

如果应用是通过快捷方式启动，但 Flutter 引擎还没初始化，路径会先存到 initialNotePath

FlutterEngine 初始化后，会调用 openNote 将路径传给 Flutter

假设你点击桌面快捷方式： 系统收到快捷方式的点击事件, 系统根据快捷方式的 Intent 创建或复用 MainActivity, 如果应用没启动 → 冷启动 → 调用 onCreate, 如果应用已在后台 → Activity 已存在 → 调用 onNewIntent, Activity 内部调用 handleIntent(intent), handleIntent 判断 action 是否 "OPEN_NOTE", 通过 MethodChannel 或暂存路径通知 Flutter 打开对应笔记

## 数据

上网上的就是一个数据, 各种各样有意思的, 要么社交属性很强, 要么学习了解, 或者AI生成, 由于老是提到数据, 导致没有好好考虑这个词, 从而远低估了数据的重要性

## npm 被系统拒绝

参考: https://www.cnblogs.com/javaxubo/p/17521253.html

是node文件夹不装在C盘的原因, 把node_cache和node_global属性中User的权限全部加上, 这样就不用管理员运行也成功

## 本地中日文字幕播放器

把字幕改为悬浮在最上方的, 全屏视频时候也可以的那种(done)

改为浏览形式, 两个页面, 一个HomePage, 即/public, 扫描其下文件夹, 一个文件夹就是一个动漫, 里面有集数的文件夹, 1就代表第一集, 里面有MP4以及字幕文件, 可能有Dash文件, 没有的话就是直接播放MP4, Dash是为了可能要在服务器部署, 看情况吧(done)

前端部署到服务器上, 带有域名以及https(done, 使用freedns获得免费域名)

写后端(done, nginx配置请求转发api, 然后fastapi跑在local)

下载视频并无损转换为MP4的python过程(done)

日文字幕合并同时间字幕, 提取出台词AI翻译为中文, 中文台词生成字幕文件, 给标上日文台词罗马音, 生成最终日文字幕文件(done)

已经没用了, 不过写了一点react感觉还有点意思, 同时nginx以及fasapi端口配置感觉也学了一点后端, 讲一讲替代方案, 使用VLC直接连接服务器开放的视频端口即可, 然后把双语字幕传到手机本地加载

## Web开发

感觉开发Web单纯的前端或者后端都有点无聊, 得前后端连上的那一刻就舒服了

## 算法推荐也许不那么好用

直接看一个人的主页与关注来顺藤摸瓜地看内容好像比直接看推荐的内容更好, 因为推荐会有广告和营销号, 而经过真人过滤过的信息至少不会是毫无意义的广告

## water timer

需求: 一个置顶窗口, 像是往一个瓶子里装水一样地记录时间, 每过一分钟水瓶里水面增高, 用于控制自己每天的代码时间在4-6小时

**road map**

- 开一个置顶窗口(done, 使用win32 以及回调实现移动, 还加了按钮)
- 引入时间绘图(每过一秒就增加作为测试, )

shader src->program(和window绑定, NDC坐标意味着画在这个窗口)->vao vbo(每个按钮有自己的, 用于坐标之类的)

像是一个瓶子一样, 每过一分钟就瓶子内水面就增长一点然后水的颜色也会随着时间变化, 我想的是少的时候淡青色, 越往上越红或者越紫, 然后每半个小时有一个刻度来让我知道大概时间, 最高是6小时, 也就是有12个刻度, 然后如果我把鼠标放到窗口上的时候下方出现四个颜色不一的矩形按钮(鼠标不在窗口上则不出现), 点击它们的功能是清空时间记录, 开始记录时间, 暂停时间,以及关闭这个程序, 然后假设现在暂停的话那么瓶子周围应该有一个边框像是冻结住一样显示现在暂停, OK, 我们一步步来, 先给我一个置顶的窗口, 我可以拖动它以及鼠标放上去的时候出现四个矩形按钮, 先不管前三个, 最后一个实现点击后退出程序,这里我感觉可以用同一个类实现, 也就是说现在有两个类, 第一个是整个窗口的, 第二个是矩形按钮类被窗口类使用, 另外画图的话我使用shader的vao和vbo来画 

RectButton:

x, y, w, h, r, g, b, a

layout函数来统一调整大小坐标

使用SDL3重构中,opengl太复杂了

基本形状加按钮退出 done

不作为一个alt+tab可切换窗口存在着 done

可以点击拖动 done

画出刻度 done

画出暂停时候的蓝色矩形方框 done 

展示渐变水面计时 done

数据json持久化,开始时刻加清空或者结束退出时候的分钟 done 

简单的可视化以及统计数据展示 done 但是还可以美化(SDL不是线程安全的,一个exe最好只用一个SDL上下文,使用main编译然后正式运行的时候使用bat重定向输出到log然后就可以没有控制台了)

鼠标点击可以透过窗户到后方

